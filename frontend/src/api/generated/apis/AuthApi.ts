/* tslint:disable */
/* eslint-disable */
/**
 * ILP API
 * Internal Loyalty Program API Specification
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';

import type {
    ErrorMessage,
    JwtResponse,
    LoginRequest,
    MessageResponse,
    SignupRequest,
    TokenRefreshRequest,
    TokenRefreshResponse,
} from '../models';
import {
    ErrorMessageFromJSON,
    ErrorMessageToJSON,
    JwtResponseFromJSON,
    JwtResponseToJSON,
    LoginRequestFromJSON,
    LoginRequestToJSON,
    MessageResponseFromJSON,
    MessageResponseToJSON,
    SignupRequestFromJSON,
    SignupRequestToJSON,
    TokenRefreshRequestFromJSON,
    TokenRefreshRequestToJSON,
    TokenRefreshResponseFromJSON,
    TokenRefreshResponseToJSON,
} from '../models';

export interface AuthenticateUserRequest {
    loginRequest: LoginRequest;
}

export interface RefreshTokenRequest {
    tokenRefreshRequest: TokenRefreshRequest;
}

export interface RegisterUserRequest {
    signupRequest: SignupRequest;
}

/**
 *
 */
export class AuthApi extends runtime.BaseAPI {
    /**
     * obtain JWT
     */
    async authenticateUserRaw(
        requestParameters: AuthenticateUserRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<JwtResponse>> {
        if (requestParameters.loginRequest === null || requestParameters.loginRequest === undefined) {
            throw new runtime.RequiredError(
                'loginRequest',
                'Required parameter requestParameters.loginRequest was null or undefined when calling authenticateUser.',
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token('bearerAuth', []);

            if (tokenString) {
                headerParameters['Authorization'] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request(
            {
                path: `/api/ilp/auth/login`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: LoginRequestToJSON(requestParameters.loginRequest),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => JwtResponseFromJSON(jsonValue));
    }

    /**
     * obtain JWT
     */
    async authenticateUser(
        requestParameters: AuthenticateUserRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<JwtResponse> {
        const response = await this.authenticateUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logout and invalidate jwt and refresh token
     */
    async logoutUserRaw(
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<MessageResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token('bearerAuth', []);

            if (tokenString) {
                headerParameters['Authorization'] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request(
            {
                path: `/api/ilp/auth/logout`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => MessageResponseFromJSON(jsonValue));
    }

    /**
     * logout and invalidate jwt and refresh token
     */
    async logoutUser(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MessageResponse> {
        const response = await this.logoutUserRaw(initOverrides);
        return await response.value();
    }

    /**
     * refresh expired jwt
     */
    async refreshTokenRaw(
        requestParameters: RefreshTokenRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<TokenRefreshResponse>> {
        if (requestParameters.tokenRefreshRequest === null || requestParameters.tokenRefreshRequest === undefined) {
            throw new runtime.RequiredError(
                'tokenRefreshRequest',
                'Required parameter requestParameters.tokenRefreshRequest was null or undefined when calling refreshToken.',
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token('bearerAuth', []);

            if (tokenString) {
                headerParameters['Authorization'] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request(
            {
                path: `/api/ilp/auth/refreshtoken`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: TokenRefreshRequestToJSON(requestParameters.tokenRefreshRequest),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenRefreshResponseFromJSON(jsonValue));
    }

    /**
     * refresh expired jwt
     */
    async refreshToken(
        requestParameters: RefreshTokenRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<TokenRefreshResponse> {
        const response = await this.refreshTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * register new user
     */
    async registerUserRaw(
        requestParameters: RegisterUserRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<runtime.ApiResponse<MessageResponse>> {
        if (requestParameters.signupRequest === null || requestParameters.signupRequest === undefined) {
            throw new runtime.RequiredError(
                'signupRequest',
                'Required parameter requestParameters.signupRequest was null or undefined when calling registerUser.',
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token('bearerAuth', []);

            if (tokenString) {
                headerParameters['Authorization'] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request(
            {
                path: `/api/ilp/auth/register`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: SignupRequestToJSON(requestParameters.signupRequest),
            },
            initOverrides,
        );

        return new runtime.JSONApiResponse(response, (jsonValue) => MessageResponseFromJSON(jsonValue));
    }

    /**
     * register new user
     */
    async registerUser(
        requestParameters: RegisterUserRequest,
        initOverrides?: RequestInit | runtime.InitOverrideFunction,
    ): Promise<MessageResponse> {
        const response = await this.registerUserRaw(requestParameters, initOverrides);
        return await response.value();
    }
}
